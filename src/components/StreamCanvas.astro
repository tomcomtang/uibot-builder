---
/**
 * StreamCanvas 组件 - Three.js 粒子流动特效
 * 纯背景装饰，不影响内容层
 */
---

<div class="stream-canvas-wrapper">
  <canvas id="stream-canvas"></canvas>
</div>

<style>
  .stream-canvas-wrapper {
    position: relative;
    width: 100%;
    height: 240px;
    pointer-events: none;
    z-index: 10;
    overflow: hidden;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>

<script>
  // 导入 Three.js
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';

  class StreamAnimation {
    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.init();
      this.createParticles();
      this.animate();
      
      window.addEventListener('resize', () => this.onResize());
    }

    private canvas: HTMLCanvasElement;
    private scene!: THREE.Scene;
    private camera!: THREE.PerspectiveCamera;
    private renderer!: THREE.WebGLRenderer;
    private particles!: THREE.Points;
    private particleCount = 600; // 减少粒子数量：从800减到600

    init() {
      this.scene = new THREE.Scene();

      const wrapper = this.canvas.parentElement!;
      const aspect = wrapper.clientWidth / wrapper.clientHeight;
      this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
      this.camera.position.z = 400; // 调整相机距离适应240px高度

      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: true
      });
      this.renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    createParticles() {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(this.particleCount * 3);
      const velocities = new Float32Array(this.particleCount * 3);
      const colors = new Float32Array(this.particleCount * 3);
      const sizes = new Float32Array(this.particleCount);

      const color1 = new THREE.Color(0x6432e6);
      const color2 = new THREE.Color(0x8a2be2);
      const color3 = new THREE.Color(0x9370db);

      for (let i = 0; i < this.particleCount; i++) {
        const i3 = i * 3;

        // 从左到右均匀分布（初始时铺满整个屏幕，两侧加强）
        positions[i3] = (Math.random() - 0.5) * 1600; // 扩大X轴范围到±800，覆盖更宽区域
        positions[i3 + 1] = (Math.random() - 0.5) * 300; // Y轴范围
        positions[i3 + 2] = (Math.random() - 0.5) * 500; // Z轴范围

        // 主要向右移动（速度加快）
        velocities[i3] = Math.random() * 0.5 + 0.4; // x: 向右（0.4-0.9，比之前的0.2-0.5快）
        velocities[i3 + 1] = (Math.random() - 0.5) * 0.2; // y: 轻微上下
        velocities[i3 + 2] = (Math.random() - 0.5) * 0.2; // z: 轻微前后

        const colorChoice = Math.floor(Math.random() * 3);
        const selectedColor = colorChoice === 0 ? color1 : colorChoice === 1 ? color2 : color3;
        colors[i3] = selectedColor.r;
        colors[i3 + 1] = selectedColor.g;
        colors[i3 + 2] = selectedColor.b;

        // 随机大小：3 到 8 之间（增大粒子尺寸上限）
        sizes[i] = Math.random() * 5 + 3;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      // 创建星星贴图
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d')!;
      
      // 绘制星星
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      const centerX = 32, centerY = 32, outerRadius = 28, innerRadius = 12;
      for (let i = 0; i < 5; i++) {
        const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
        const x = centerX + Math.cos(angle) * outerRadius;
        const y = centerY + Math.sin(angle) * outerRadius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        
        const innerAngle = angle + (2 * Math.PI) / 5;
        const ix = centerX + Math.cos(innerAngle) * innerRadius;
        const iy = centerY + Math.sin(innerAngle) * innerRadius;
        ctx.lineTo(ix, iy);
      }
      ctx.closePath();
      ctx.fill();
      
      // 添加光晕
      const gradient = ctx.createRadialGradient(32, 32, 10, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 64, 64);

      const texture = new THREE.CanvasTexture(canvas);

      const material = new THREE.PointsMaterial({
        size: 6, // 增大基础尺寸：从5改为6
        map: texture,
        vertexColors: true,
        transparent: true,
        opacity: 0.85,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
      });

      this.particles = new THREE.Points(geometry, material);
      this.scene.add(this.particles);
    }

    animate = () => {
      requestAnimationFrame(this.animate);

      const positions = this.particles.geometry.attributes.position.array as Float32Array;
      const velocities = this.particles.geometry.attributes.velocity.array as Float32Array;

      for (let i = 0; i < this.particleCount; i++) {
        const i3 = i * 3;

        positions[i3] += velocities[i3];
        positions[i3 + 1] += velocities[i3 + 1];
        positions[i3 + 2] += velocities[i3 + 2];

        // 从左到右循环（扩大范围覆盖两侧）
        if (positions[i3] > 800) {
          positions[i3] = -800;
          positions[i3 + 1] = (Math.random() - 0.5) * 300;
          positions[i3 + 2] = (Math.random() - 0.5) * 500;
        }
        
        // Y 和 Z 方向保持范围（调整边界）
        if (positions[i3 + 1] > 150) positions[i3 + 1] = -150;
        if (positions[i3 + 1] < -150) positions[i3 + 1] = 150;
        if (positions[i3 + 2] > 250) positions[i3 + 2] = -250;
        if (positions[i3 + 2] < -250) positions[i3 + 2] = 250;
        
        // 从左边界重新进入时保持范围
        if (positions[i3] < -800) positions[i3] = 800;
      }

      this.particles.geometry.attributes.position.needsUpdate = true;

      // 不旋转，保持从左到右的水平流动
      this.renderer.render(this.scene, this.camera);
    };

    onResize() {
      const wrapper = this.canvas.parentElement!;
      const aspect = wrapper.clientWidth / wrapper.clientHeight;
      this.camera.aspect = aspect;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
    }
  }

  const canvas = document.getElementById('stream-canvas') as HTMLCanvasElement;
  if (canvas) {
    new StreamAnimation(canvas);
  }
</script>
